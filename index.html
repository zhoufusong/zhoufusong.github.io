<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="大前端、算法方向">
<meta property="og:type" content="website">
<meta property="og:title" content="御风的博客，keep going！">
<meta property="og:url" content="https://zhoufusong.github.io/index.html">
<meta property="og:site_name" content="御风的博客，keep going！">
<meta property="og:description" content="大前端、算法方向">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="御风的博客，keep going！">
<meta name="twitter:description" content="大前端、算法方向">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhoufusong.github.io/"/>





  <title>御风的博客，keep going！</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9e5cd8343041619d5831f1168cecb2b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">御风的博客，keep going！</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">iOS（React Native）工程师，基本会保持每周一更</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photos">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            照片
          </a>
        </li>
      
        
        <li class="menu-item menu-item-book">
          <a href="/book/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            书籍
          </a>
        </li>
      
        
        <li class="menu-item menu-item-movies">
          <a href="/movies/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-film"></i> <br />
            
            电影
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'iP8-2uJDBv1aAnXsLdb-','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhoufusong.github.io/2017/12/24/Runloop学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yufeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="御风的博客，keep going！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/24/Runloop学习笔记/" itemprop="url">Runloop学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-24T15:29:49+08:00">
                2017-12-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Runloop是iOS开发中非常重要和基础的概念，虽然在平时的开发中使用不多，但是它能帮助我们发现和解决许多疑难问题，也是iOS知识体系中为数不多的比较考验开发者能力的东东。话不多说，快一起来看看吧。</p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul>
<li>每个线程都关联着一个Runloop对象。</li>
<li>主线程的Runloop在应用启动时会默认开启，而子线程的Runloop则不会，当第一次获取子线程的Runloop时才会创建。在线程结束时销毁。</li>
<li>Runloop的目的是为了当线程有事做的时候保持运行，无事做的时候保持休眠状态。实际上就是使线程一直处于：接受消息 –&gt; 等待 –&gt; 处理消息的循环中（event loop 模型）。</li>
<li>具体实现在：CoreFoundation框架中有个CFRunLoopRef对象，提供纯C函数的API，线程安全；cocoa框架中有个NSRunLoop对象，它是CFRunLoopRef的面向对象的封装，这些面向对象的API不是线程安全的。</li>
</ul>
<h4 id="关键要素"><a href="#关键要素" class="headerlink" title="关键要素"></a>关键要素</h4><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>一个Runloop包含多个mode，每个mode又包含多个source/timer/observer，Runloop每次只能运行在某一个mode中，如果需要切换mode，必须退出当前Runloop再重新指定一个 Mode 进入，这样可以确保每个mode的事件之间互不影响。从CFRunLoopRef的源码更能反映这种关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;			<span class="comment">/* locked for accessing mode list */</span></div><div class="line">    __CFPort _wakeUpPort;			<span class="comment">// used for CFRunLoopWakeUp </span></div><div class="line">    Boolean _unused;</div><div class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></div><div class="line">    <span class="keyword">pthread_t</span> _pthread;                  <span class="comment">//Runloop对应的线程</span></div><div class="line">    <span class="keyword">uint32_t</span> _winthread;                 </div><div class="line">    CFMutableSetRef _commonModes; 		 <span class="comment">//存储的是字符串，记录所有标记为common的mode</span></div><div class="line">    CFMutableSetRef _commonModeItems;	 <span class="comment">//存储所有commonMode的item(source、timer、observer)</span></div><div class="line">    CFRunLoopModeRef _currentMode;       <span class="comment">//当前所在的mode</span></div><div class="line">    CFMutableSetRef _modes;              <span class="comment">//所有mode的集合</span></div><div class="line">    <span class="keyword">struct</span> _block_item *_blocks_head;</div><div class="line">    <span class="keyword">struct</span> _block_item *_blocks_tail;</div><div class="line">    CFAbsoluteTime _runTime;</div><div class="line">    CFAbsoluteTime _sleepTime;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>那么mode的结构定义又是什么呢？从代码中可以看出mode下包含着若干的source、observer和timers（这些统称为modeItem，在mode的定义中有此对应属性，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。所以要保持一个 mode 活着，就必须往里面添加至少一个 source、timer 或 observer 。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;	<span class="comment">/* must have the run loop locked before locking this */</span></div><div class="line">    CFStringRef _name;               <span class="comment">//mode名称</span></div><div class="line">    Boolean _stopped;</div><div class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</div><div class="line">    CFMutableSetRef _sources0;       <span class="comment">//sources0 set</span></div><div class="line">    CFMutableSetRef _sources1;       <span class="comment">//sources1 set</span></div><div class="line">    CFMutableArrayRef _observers;    <span class="comment">//observer set</span></div><div class="line">    CFMutableArrayRef _timers;       <span class="comment">//timer set</span></div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;<span class="comment">//字典 mach_port_t:CFRunLoopSourceRef</span></div><div class="line">    __CFPortSet _portSet;            <span class="comment">//保存所有需要监听的port</span></div><div class="line">    CFIndex _observerMask;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></div><div class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</div><div class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</div><div class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></div><div class="line">    <span class="keyword">mach_port_t</span> _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">    DWORD _msgQMask;</div><div class="line">    <span class="keyword">void</span> (*_msgPump)(<span class="keyword">void</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></div><div class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>苹果文档公开定义的mode有5个，而源码中只有default和commonModes，这5个分别是：</p>
<ul>
<li>NSDefaultRunLoopMode(cocoa)/kCFRunLoopDefaultMode (Core Foundation)：App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>NSConnectionReplyMode：处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。</li>
<li>NSModalPanelRunLoopMode：处理modal panels事件。</li>
<li>NSEventTrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>NSRunLoopCommonModes(Cocoa)/kCFRunLoopCommonModes (Core Foundation)：，它不是一个真正的 mode，而是若干个 mode 的集合，加到 <code>CommonMode</code> 的 <code>source/timer/observer</code> 相当于添加到了它里面所有的 mode 中。</li>
</ul>
<p>CFRunLoopSource分source0和source1两个版本（纳闷为啥不取一个更表意的名字呢？哈哈），它的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopSource &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">uint32_t</span> _bits;     <span class="comment">//用于标记Signaled状态，source0只有在被标记为Signaled状态，才会被处理</span></div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></div><div class="line">    CFMutableBagRef _runLoops;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">	    CFRunLoopSourceContext version0;	<span class="comment">/* immutable, except invalidation */</span></div><div class="line">        CFRunLoopSourceContext1 version1;	<span class="comment">/* immutable, except invalidation */</span></div><div class="line">    &#125; _context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>source0是App内部事件，由App自己管理的UIEvent、CFSocket都是source0。Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。以下是source0的上下文结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</div><div class="line">    CFHashCode	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*schedule)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);</div><div class="line">    <span class="keyword">void</span>	(*cancel)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);</div><div class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info);</div><div class="line">&#125; CFRunLoopSourceContext;</div></pre></td></tr></table></figure>
<p>source1由RunLoop和内核管理，source1带有mach_port_t和一个回调（函数指针），可以接收内核消息并触发回调。这种 Source 能主动唤醒 RunLoop 的线程。以下是source1的上下文结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    CFIndex	version;</div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</div><div class="line">    CFHashCode	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span></div><div class="line">    <span class="keyword">mach_port_t</span>	(*getPort)(<span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span> *	(*perform)(<span class="keyword">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="keyword">void</span> *info);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">void</span> *	(*getPort)(<span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125; CFRunLoopSourceContext1;</div></pre></td></tr></table></figure>
<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调，其结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopTimer &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">uint16_t</span> _bits;                         <span class="comment">//标记fire状态</span></div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">    CFRunLoopRef _runLoop;                  <span class="comment">//添加该timer的runloop</span></div><div class="line">    CFMutableSetRef _rlModes;   <span class="comment">//存放所有包含该timer的mode的名字，即一个timer可能会在多个mode中</span></div><div class="line">    CFAbsoluteTime _nextFireDate;</div><div class="line">    CFTimeInterval _interval;		<span class="comment">/* immutable */</span>  <span class="comment">//理想时间间隔 </span></div><div class="line">    CFTimeInterval _tolerance;          <span class="comment">/* mutable */</span>  <span class="comment">//能容忍的时间偏差</span></div><div class="line">    <span class="keyword">uint64_t</span> _fireTSR;			<span class="comment">/* TSR units */</span></div><div class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopTimerCallBack _callout;	<span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopTimerContext _context;	<span class="comment">/* immutable, except invalidation */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能接受到这个变化触发回调。可以观测的时间点有以下几个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Run Loop Observer Activities */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),            <span class="comment">// 即将进入Loop</span></div><div class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),     <span class="comment">// 即将处理 Timer</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),    <span class="comment">// 即将处理 Source</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),    <span class="comment">// 即将进入休眠</span></div><div class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),     <span class="comment">// 刚从休眠中唤醒</span></div><div class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),             <span class="comment">// 即将退出Loop</span></div><div class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U    <span class="comment">// 以上所有事件</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>####运行流程</p>
<p>1、Runloop的获取</p>
<p>苹果不允许我们创建 RunLoop，要获取主线程或当前线程对应的 RunLoop，只能通过 <code>CFRunLoopGetMain</code>或 <code>CFRunLoopGetCurrent</code> 函数，获取过程大致如下：</p>
<p>CFRunLoopGetCurrent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());  <span class="comment">//传入当前线程</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopGetCurrent函数内部调用了_CFRunLoopGet0()，传入的参数是当前线程。这里可以看出，CFRunLoopGetCurrent函数必须要在线程内部调用，才能获取当前线程的RunLoop。也就是说子线程的RunLoop必须要在子线程内部获取。</p>
<p>CFRunLoopGetMain</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    <span class="keyword">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></div><div class="line">    <span class="comment">//传入主线程</span></div><div class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></div><div class="line">    <span class="keyword">return</span> __main;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopGetMain函数内部也调用了_CFRunLoopGet0()，传入的参数是主线程。CFRunLoopGetMain()不管在主线程还是子线程中调用，都可以获取到主线程的RunLoop。</p>
<p>CFRunLoopGet0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock = CFSpinLockInit;</div><div class="line"></div><div class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</div><div class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</div><div class="line">		t = pthread_main_thread_np();</div><div class="line">    &#125;</div><div class="line">    __CFLock(&amp;loopsLock);</div><div class="line">   	<span class="comment">//如果存储RunLoop的字典不存在</span></div><div class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">      	<span class="comment">//创建一个临时字典dict</span></div><div class="line">		CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">      	<span class="comment">//创建主线程的RunLoop</span></div><div class="line">		CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line">      	<span class="comment">//把主线程的RunLoop保存到dict中，key是线程，value是RunLoop</span></div><div class="line">		CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">		<span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</div><div class="line">	    	CFRelease(dict);</div><div class="line">		&#125;</div><div class="line">		CFRelease(mainLoop);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">    &#125;</div><div class="line">   	<span class="comment">//以上说明，第一次进来的时候，不管是getMainRunloop还是get子线程的runloop，主线程的runloop总是会被创建</span></div><div class="line">    <span class="comment">//从字典__CFRunLoops中获取传入线程t的runloop</span></div><div class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">    __CFUnlock(&amp;loopsLock);</div><div class="line">   <span class="comment">//如果没有获取到</span></div><div class="line">    <span class="keyword">if</span> (!loop) &#123;</div><div class="line">      	<span class="comment">//根据线程t创建一个runloop</span></div><div class="line">		CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class="line">        __CFLock(&amp;loopsLock);</div><div class="line">		loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">		<span class="keyword">if</span> (!loop) &#123;</div><div class="line">       		<span class="comment">//把newLoop存入字典__CFRunLoops，key是线程t</span></div><div class="line">	    	CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">	    	loop = newLoop;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">// don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></div><div class="line">        __CFUnlock(&amp;loopsLock);</div><div class="line">		CFRelease(newLoop);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果传入线程就是当前线程</span></div><div class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">          <span class="comment">//注册一个回调，当线程销毁时，销毁对应的RunLoop</span></div><div class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，线程和 RunLoop 是一一对应的，对应关系保存在一个全局的 dictionary 中。RunLoop 类似懒加载，只有在第一次获取的时候才会创建。当线程销毁时，也销毁对应的 RunLoop。</p>
<p>2、RunLoop 的运行</p>
<p>run loop的内部逻辑是一个do..while循环，它遍历所有事件，有事件处理的时候让线程工作，没有事件处理的时候让线程休眠。运行过程大概是这样的：</p>
<p>（1）通知observers 即将进入run loop</p>
<p>（2）通知observes 即将开始处理timer source</p>
<p>（3）通知observes 即将开始处理非port-based input sources（不包括port-based source，也就是source0）</p>
<p>（4）开始处理非port-based input sources（也就是source0）</p>
<p>（5）如果有port-based source（source1）待处理，则开始处理port-based source，跳转到第9步</p>
<p>（6）通知observes线程即将进入休眠</p>
<p>（7）让线程进入休眠状态，直到有以下事件发生：</p>
<ul>
<li>收到基于端口的输入源（source1）事件消息</li>
<li>定时器事件需要执行</li>
<li>run loop的超时时间到了</li>
<li>外部手动唤醒</li>
</ul>
<p>（8）通知observes 线程被唤醒</p>
<p>（9）处理唤醒时收到的待处理事件消息</p>
<ul>
<li>如果自定义的timer被fire，那么执行该timer事件并重新开始循环，跳转到第2步</li>
<li>如果input source被fire，则处理该事件</li>
<li>如果run loop被外部手动唤醒，并且没有超时，那么重新开始循环，跳转到第2步</li>
</ul>
<p>（10）通知observes run loop已经退出</p>
<p>在Runloop的源码中是这样实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认使用kCFRunLoopDefaultMode运行runloop</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;	<span class="comment">/* DOES CALLOUT */</span></div><div class="line">    <span class="keyword">int32_t</span> result;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">      	<span class="comment">//默认在kCFRunLoopDefaultMode下运行runloop</span></div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopRun函数中调用了CFRunLoopRunSpecific函数，runloop参数传入当前RunLoop对象，modeName参数传入kCFRunLoopDefaultMode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopRunInMode函数中也调用了CFRunLoopRunSpecific函数，runloop参数传入当前RunLoop对象，modeName参数继续传递CFRunLoopRunInMode传入的modeName。同时允许设置RunLoop超时时间。</p>
<p>它们都调用了CFRunLoopRunSpecific函数来运行Runloop，所以我们接着往里看：</p>
<p>CFRunLoopRunSpecific</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 指定mode运行runloop</div><div class="line"> * @param rl 当前运行的runloop</div><div class="line"> * @param modeName 需要运行的mode的name</div><div class="line"> * @param seconds  runloop的超时时间</div><div class="line"> * @param returnAfterSourceHandled 是否处理完事件就返回</div><div class="line"> */</div><div class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">  	<span class="comment">//根据modeName找到本次运行的mode</span></div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</div><div class="line">  	<span class="comment">//如果没找到 || mode中没有注册任何事件，则就此停止，不进入循环</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode))   	&#123;</div><div class="line">		Boolean did = <span class="literal">false</span>;</div><div class="line">		<span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">		__CFRunLoopUnlock(rl);</div><div class="line">		<span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将当前运行的mode进行保存并将mode切换到modename对应mode</span></div><div class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    <span class="keyword">int32_t</span> result = kCFRunLoopRunFinished;</div><div class="line">    <span class="comment">// 1.通知observer即将进入runloop</span></div><div class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">    <span class="comment">// 进入 loop</span></div><div class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">    <span class="comment">//10.通知observer已退出runloop</span></div><div class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line">	<span class="comment">//取出保存的mode并置为当前mode</span></div><div class="line">    __CFRunLoopModeUnlock(currentMode);</div><div class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">	rl-&gt;_currentMode = previousMode;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从CFRunLoopRunSpecific可以看到这些知识：</p>
<ul>
<li>如果指定了一个不存在的mode来运行RunLoop，那么会失败，mode不会被创建，所以这里传入的mode必须是存在的</li>
<li>如果指定了一个mode，但是这个mode中不包含任何modeItem，那么RunLoop也不会运行，所以必须要传入至少包含一个modeItem的mode</li>
<li>在进入run loop之前通知observer，状态为kCFRunLoopEntry</li>
<li>在退出run loop之后通知observer，状态为kCFRunLoopExit</li>
</ul>
<p>最核心的是__CFRunLoopRun函数，所以接下来进一步看看它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  运行run loop</div><div class="line"> *</div><div class="line"> *  @param rl              运行的RunLoop对象</div><div class="line"> *  @param rlm             运行的mode</div><div class="line"> *  @param seconds         run loop超时时间</div><div class="line"> *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止</div><div class="line"> *  @param previousMode    上一次运行的mode</div><div class="line"> *</div><div class="line"> *  @return 返回4种状态</div><div class="line"> */</div><div class="line"><span class="comment">/* rl, rlm are locked on entrance and exit */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">  	<span class="comment">//获取系统启动后的CPU运行时间，用于控制超时时间</span></div><div class="line">    <span class="keyword">uint64_t</span> startTSR = mach_absolute_time();</div><div class="line">	<span class="comment">//如果RunLoop或者mode是stop状态，则直接return，不进入循环</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">		<span class="keyword">return</span> kCFRunLoopRunStopped;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</div><div class="line">		rlm-&gt;_stopped = <span class="literal">false</span>;</div><div class="line">		<span class="keyword">return</span> kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//mach端口，在内核中，消息在端口之间传递。 初始为0</span></div><div class="line">    <span class="keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</div><div class="line">  	<span class="comment">//判断是否为主线程</span></div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">  	<span class="comment">//如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口</span></div><div class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></div><div class="line">    <span class="keyword">mach_port_name_t</span> modeQueuePort = MACH_PORT_NULL;</div><div class="line">    <span class="keyword">if</span> (rlm-&gt;_queue) &#123;</div><div class="line">      	<span class="comment">//mode赋值为dispatch端口_dispatch_runloop_root_queue_perform_4CF</span></div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        <span class="keyword">if</span> (!modeQueuePort) &#123;</div><div class="line">            CRASH(<span class="string">"Unable to get port for run loop mode queue (%d)"</span>, <span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">//GCD管理的定时器，用于实现runloop超时机制</span></div><div class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> __timeout_context *timeout_context = (<span class="keyword">struct</span> __timeout_context *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*timeout_context));</div><div class="line">  	<span class="comment">//立即超时</span></div><div class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></div><div class="line">        seconds = <span class="number">0.0</span>;</div><div class="line">        timeout_context-&gt;termTSR = <span class="number">0U</span>LL;</div><div class="line">      <span class="comment">//seconds为超时时间，超时时执行__CFRunLoopTimeout函数</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">		<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class="line">		timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">queue</span>);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">		timeout_context-&gt;ds = timeout_timer;</div><div class="line">		timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">		timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">		dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></div><div class="line">		dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        <span class="keyword">uint64_t</span> ns_at = (<span class="keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="number">1000000000U</span>LL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000U</span>LL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></div><div class="line">      	<span class="comment">//永不超时</span></div><div class="line">        seconds = <span class="number">9999999999.0</span>;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//标志位默认为true</span></div><div class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</div><div class="line">  	<span class="comment">//记录最后runloop状态，用于return</span></div><div class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></div><div class="line">        <span class="keyword">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</div><div class="line">        <span class="keyword">voucher_t</span> voucherCopy = <span class="literal">NULL</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      	<span class="comment">//初始化一个存放内核消息的缓冲池</span></div><div class="line">        <span class="keyword">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></div><div class="line">        <span class="keyword">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">mach_port_t</span> livePort = MACH_PORT_NULL;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">        HANDLE livePort = <span class="literal">NULL</span>;</div><div class="line">        Boolean windowsMessageReceived = <span class="literal">false</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    	<span class="comment">//取所有需要监听的port</span></div><div class="line">		__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line">		<span class="comment">//设置RunLoop为可以被唤醒状态</span></div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">		<span class="comment">//2.通知observer，即将触发timer回调，处理timer事件</span></div><div class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">      	<span class="comment">//3.通知observer，即将触发Source0回调</span></div><div class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">		<span class="comment">//执行加入当前runloop的block</span></div><div class="line">		__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">		<span class="comment">//4.处理source0事件</span></div><div class="line">        <span class="comment">//有事件处理返回true，没有事件返回false</span></div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">          	<span class="comment">//执行加入当前runloop的block</span></div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//如果没有Sources0事件处理 并且 没有超时，poll为false</span></div><div class="line">        <span class="comment">//如果有Sources0事件处理 或者 超时，poll都为true</span></div><div class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0U</span>LL == timeout_context-&gt;termTSR);</div><div class="line">		<span class="comment">//第一次do..whil循环不会走该分支，因为didDispatchPortLastTime初始化是true</span></div><div class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></div><div class="line">          	<span class="comment">//从缓冲区读取消息</span></div><div class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</div><div class="line">          	<span class="comment">//5.接收dispatchPort端口的消息，（接收source1事件）</span></div><div class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</div><div class="line">                 <span class="comment">//如果接收到了消息的话，前往第9步开始处理msg</span></div><div class="line">                <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">            <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="literal">NULL</span>, &amp;dispatchPort, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>)) &#123;</div><div class="line">                <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</div><div class="line">	<span class="comment">//6.通知观察者RunLoop即将进入休眠</span></div><div class="line">	<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">      	<span class="comment">//设置RunLoop为休眠状态</span></div><div class="line">		__CFRunLoopSetSleeping(rl);</div><div class="line">	<span class="comment">// do not do any user callouts after this point (after notifying of sleeping)</span></div><div class="line"></div><div class="line">        <span class="comment">// Must push the local-to-this-activation ports in on every loop</span></div><div class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></div><div class="line">        <span class="comment">// want these ports to get serviced.</span></div><div class="line"></div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">		__CFRunLoopModeUnlock(rlm);</div><div class="line">		__CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">        CFAbsoluteTime sleepStart = poll ? <span class="number">0.0</span> : CFAbsoluteTimeGetCurrent();</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></div><div class="line">      	<span class="comment">//这里有个内循环，用于接收等待端口的消息</span></div><div class="line">        <span class="comment">//进入此循环后，线程进入休眠，直到收到新消息才跳出该循环，继续执行run loop</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</div><div class="line">                <span class="comment">// objc_clear_stack(0);</span></div><div class="line">                <span class="comment">// &lt;rdar://problem/16393959&gt;</span></div><div class="line">                <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</div><div class="line">            <span class="comment">//7.接收waitSet端口的消息</span></div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">            <span class="comment">//收到消息之后，livePort的值为msg-&gt;msgh_local_port，</span></div><div class="line">            <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                <span class="comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></div><div class="line">                <span class="keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                <span class="keyword">if</span> (rlm-&gt;_timerFired) &#123;</div><div class="line">                    <span class="comment">// Leave livePort as the queue port, and service timers below</span></div><div class="line">                    rlm-&gt;_timerFired = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Go ahead and leave the inner loop.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</div><div class="line">            <span class="comment">// objc_clear_stack(0);</span></div><div class="line">            <span class="comment">// &lt;rdar://problem/16393959&gt;</span></div><div class="line">            <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        </div><div class="line">        </div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">        <span class="comment">// Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</span></div><div class="line">        __CFRunLoopWaitForMultipleObjects(waitSet, <span class="literal">NULL</span>, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">        rl-&gt;_sleepTime += (poll ? <span class="number">0.0</span> : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class="line"></div><div class="line">        <span class="comment">// Must remove the local-to-this-activation ports in on every loop</span></div><div class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></div><div class="line">        <span class="comment">// want these ports to get serviced. Also, we don't want them left</span></div><div class="line">        <span class="comment">// in there if this function returns.</span></div><div class="line"></div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">		 <span class="comment">//取消runloop的休眠状态</span></div><div class="line">        <span class="comment">// user callouts now OK again</span></div><div class="line">		__CFRunLoopUnsetSleeping(rl);</div><div class="line">      	<span class="comment">//8.通知观察者runloop被唤醒</span></div><div class="line">		<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line">		<span class="comment">//9.处理收到的消息</span></div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">        <span class="keyword">if</span> (windowsMessageReceived) &#123;</div><div class="line">            <span class="comment">// These Win32 APIs cause a callout, so make sure we're unlocked first and relocked after</span></div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">	    __CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (rlm-&gt;_msgPump) &#123;</div><div class="line">                rlm-&gt;_msgPump();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                MSG msg;</div><div class="line">                <span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE | PM_NOYIELD)) &#123;</div><div class="line">                    TranslateMessage(&amp;msg);</div><div class="line">                    DispatchMessage(&amp;msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">	    __CFRunLoopModeLock(rlm);</div><div class="line"> 	    sourceHandledThisLoop = <span class="literal">true</span>;</div><div class="line">            </div><div class="line">            <span class="comment">// To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</span></div><div class="line">            <span class="comment">// Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we're just checking to see if the things are signalled right now -- we will wait on them again later.</span></div><div class="line">            <span class="comment">// <span class="doctag">NOTE:</span> Ignore the dispatch source (it's not in the wait set anymore) and also don't run the observers here since we are polling.</span></div><div class="line">            __CFRunLoopSetSleeping(rl);</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            </div><div class="line">            __CFRunLoopWaitForMultipleObjects(waitSet, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>);</div><div class="line">            </div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);            </div><div class="line">            __CFRunLoopUnsetSleeping(rl);</div><div class="line">            <span class="comment">// If we have a new live port then it will be handled below as normal</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      	<span class="comment">// 通过判断端口，找出要处理的事件</span></div><div class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            <span class="comment">// handle nothing</span></div><div class="line">            <span class="comment">//通过CFRunloopWake唤醒</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">          	<span class="comment">//什么都不干，跳回2重新循环</span></div><div class="line">            <span class="comment">// do nothing on Mac OS</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">            <span class="comment">// Always reset the wake up port, or risk spinning forever</span></div><div class="line">            ResetEvent(rl-&gt;_wakeUpPort);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></div><div class="line">      	<span class="comment">//如果是定时器事件</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">          	<span class="comment">//9.1 处理timer事件</span></div><div class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            <span class="comment">// On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.</span></div><div class="line">            <span class="comment">// In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</span></div><div class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                <span class="comment">// Re-arm the next timer</span></div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      	<span class="comment">//如果是dispatch到main queue的block // 被 GCD 唤醒,则执行所有调用 dispatch_async 等方法放入main queue 的 block</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">            <span class="keyword">void</span> *msg = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">          	<span class="comment">//9.2执行block</span></div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</div><div class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            </div><div class="line">            <span class="comment">// If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.</span></div><div class="line">            <span class="keyword">voucher_t</span> previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (<span class="keyword">void</span> *)voucherCopy, os_release);</div><div class="line"></div><div class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">          <span class="comment">// 有source1事件待处理 // 如果被 source1（基于 port） 唤醒的，则处理这个事件</span></div><div class="line">            <span class="keyword">if</span> (rls) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></div><div class="line">		<span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</div><div class="line">        <span class="comment">//9.2 处理source1事件</span></div><div class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</div><div class="line">		    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</div><div class="line">		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">		&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	    &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// Restore the previous voucher</span></div><div class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">            </div><div class="line">        &#125; </div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></div><div class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">     <span class="comment">// 执行加入到 loop 的 block   </span></div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">	<span class="comment">// 判断是否应该退出 loop</span></div><div class="line">	<span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">      	<span class="comment">//进入run loop时传入的参数，处理完事件就返回</span></div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">      	<span class="comment">//run loop超时</span></div><div class="line">        retVal = kCFRunLoopRunTimedOut;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">      	<span class="comment">//run loop被手动终止</span></div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</div><div class="line">      	<span class="comment">//mode被终止</span></div><div class="line">	    rlm-&gt;_stopped = <span class="literal">false</span>;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">      	<span class="comment">//mode中没有要处理的事件</span></div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">        </div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></div><div class="line">        voucher_mach_msg_revert(voucherState);</div><div class="line">        os_release(voucherCopy);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	<span class="comment">//除了上面这几种情况，都继续循环</span></div><div class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">free</span>(timeout_context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>__CFRunLoopServiceMachPort</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  接收指定内核端口的消息</div><div class="line"> *</div><div class="line"> *  @param port        接收消息的端口</div><div class="line"> *  @param buffer      消息缓冲区</div><div class="line"> *  @param buffer_size 消息缓冲区大小</div><div class="line"> *  @param livePort    暂且理解为活动的端口，接收消息成功时候值为msg-&gt;msgh_local_port，超时时为MACH_PORT_NULL</div><div class="line"> *  @param timeout     超时时间，单位是ms，如果超时，则RunLoop进入休眠状态</div><div class="line"> *</div><div class="line"> *  @return 接收消息成功时返回true 其他情况返回false</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> Boolean __CFRunLoopServiceMachPort(<span class="keyword">mach_port_name_t</span> port, <span class="keyword">mach_msg_header_t</span> **buffer, <span class="keyword">size_t</span> buffer_size, <span class="keyword">mach_port_t</span> *livePort, <span class="keyword">mach_msg_timeout_t</span> timeout) &#123;</div><div class="line">    Boolean originalBuffer = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">kern_return_t</span> ret = KERN_SUCCESS;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;      <span class="comment">/* In that sleep of death what nightmares may come ... */</span></div><div class="line">        <span class="keyword">mach_msg_header_t</span> *msg = (<span class="keyword">mach_msg_header_t</span> *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = <span class="number">0</span>;  <span class="comment">//消息头的标志位</span></div><div class="line">        msg-&gt;msgh_local_port = port;  <span class="comment">//源(发出的消息)或者目标(接收的消息)</span></div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL; <span class="comment">//目标(发出的消息)或者源(接收的消息)</span></div><div class="line">        msg-&gt;msgh_size = buffer_size;  <span class="comment">//消息缓冲区大小，单位是字节</span></div><div class="line">        msg-&gt;msgh_id = <span class="number">0</span>;  <span class="comment">//唯一id</span></div><div class="line">       </div><div class="line">        <span class="keyword">if</span> (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; <span class="keyword">else</span> &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//通过mach_msg发送或者接收的消息都是指针，</span></div><div class="line">        <span class="comment">//如果直接发送或者接收消息体，会频繁进行内存复制，损耗性能</span></div><div class="line">        <span class="comment">//所以XNU使用了单一内核的方式来解决该问题，所有内核组件都共享同一个地址空间，因此传递消息时候只需要传递消息的指针</span></div><div class="line">        ret = mach_msg(msg,</div><div class="line">                       MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : <span class="number">0</span>)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV),</div><div class="line">                       <span class="number">0</span>,</div><div class="line">                       msg-&gt;msgh_size,</div><div class="line">                       port,</div><div class="line">                       timeout,</div><div class="line">                       MACH_PORT_NULL);</div><div class="line">        CFRUNLOOP_WAKEUP(ret);</div><div class="line">        </div><div class="line">        <span class="comment">//接收/发送消息成功，给livePort赋值为msgh_local_port</span></div><div class="line">        <span class="keyword">if</span> (MACH_MSG_SUCCESS == ret) &#123;</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//MACH_RCV_TIMEOUT</span></div><div class="line">        <span class="comment">//超出timeout时间没有收到消息，返回MACH_RCV_TIMED_OUT</span></div><div class="line">        <span class="comment">//此时释放缓冲区，把livePort赋值为MACH_PORT_NULL</span></div><div class="line">        <span class="keyword">if</span> (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class="line">            <span class="keyword">if</span> (!originalBuffer) <span class="built_in">free</span>(msg);</div><div class="line">            *buffer = <span class="literal">NULL</span>;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//MACH_RCV_LARGE</span></div><div class="line">        <span class="comment">//如果接收缓冲区太小，则将过大的消息放在队列中，并且出错返回MACH_RCV_TOO_LARGE，</span></div><div class="line">        <span class="comment">//这种情况下，只返回消息头，调用者可以分配更多的内存</span></div><div class="line">        <span class="keyword">if</span> (MACH_RCV_TOO_LARGE != ret) <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//此处给buffer分配更大内存</span></div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        <span class="keyword">if</span> (originalBuffer) *buffer = <span class="literal">NULL</span>;</div><div class="line">        originalBuffer = <span class="literal">false</span>;</div><div class="line">        *buffer = <span class="built_in">realloc</span>(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的过程实际上代码上已经非常明了，这里借用网上看到的一张图表示：</p>
<p><img src="runloopLifeCycle.png" alt=""></p>
<p>在堆栈中可以看到各种事件的回调函数,在代码中实际上就是调用回调的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</div><div class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</div></pre></td></tr></table></figure>
<p>实际上接近4000行的源码中依然还有很多内容未涉及，后面会慢慢理解补充。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhoufusong.github.io/2017/12/23/React组件生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yufeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="御风的博客，keep going！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/23/React组件生命周期/" itemprop="url">React组件的生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T22:01:23+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>####前言</p>
<p>最近在做RN项目，实际上也是继承的React的这套生命周期方法，而且使用了ES6语法，使用上更加直观便利。所以想学习一下React的life-cycle方法。</p>
<p>在React中，一个组件就是一个状态机，对于特定地输入，它总返回一致的输出。在 React（react native） 的组件化中，有很多有意思的东西，此处想聊一下非常基础也很重要的组件的生命周期，简单地说组件主要就是三个状阶段：mount（组件挂载、已插入真实 DOM）、update（组件更新、正在被重新渲染）和unmount（组件的卸载、已移出真实 DOM）。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/12/23/React组件生命周期/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhoufusong.github.io/2017/04/27/swift字符串的一些操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yufeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="御风的博客，keep going！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/27/swift字符串的一些操作/" itemprop="url">swift字符串的一些操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T23:45:23+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>swift字符串的一些操作</p>
<p>1、删除字符串前后多余的空格(内部空格没有影响)</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/27/swift字符串的一些操作/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhoufusong.github.io/2017/03/05/leetcode之Max Consecutive Ones/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yufeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="御风的博客，keep going！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/05/leetcode之Max Consecutive Ones/" itemprop="url">LeetCode-Max Consecutive Ones</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-05T19:23:23+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="问题Max-Consecutive-Ones"><a href="#问题Max-Consecutive-Ones" class="headerlink" title="问题Max Consecutive Ones"></a>问题Max Consecutive Ones</h4><p>描述：给定二进制的一个数组，找出在数组中连续的1的最大个数，例如[1,1,0,1,1,1]，输出为3</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/05/leetcode之Max Consecutive Ones/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhoufusong.github.io/2017/03/05/leetcode之Find All Numbers Disappeared in an Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yufeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="御风的博客，keep going！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/05/leetcode之Find All Numbers Disappeared in an Array/" itemprop="url">LeetCode-Find All Numbers Disappeared in an Array</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-05T19:22:23+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="问题：Find-All-Numbers-Disappeared-in-an-Array"><a href="#问题：Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="问题：Find All Numbers Disappeared in an Array"></a>问题：Find All Numbers Disappeared in an Array</h4><p>描述：给定一个整数数组（1 ≤ a[i] ≤n，n是数组的大小），一些元素出现两次而其他元素只出现一次，找出在[1,n]中所有没有出现在数组中的元素。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/05/leetcode之Find All Numbers Disappeared in an Array/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhoufusong.github.io/2017/03/05/LeetCode之Third Maximum Number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yufeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="御风的博客，keep going！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/05/LeetCode之Third Maximum Number/" itemprop="url">LeetCode-Third Maximum Number</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-05T19:21:23+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="问题-Third-Maximum-Number"><a href="#问题-Third-Maximum-Number" class="headerlink" title="问题 Third Maximum Number"></a>问题 Third Maximum Number</h4><p>描述：给定非空整数数组，返回数组中第三大的数，如果它不存在，返回最大的数。时间复杂度必须是O(n)</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/05/LeetCode之Third Maximum Number/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhoufusong.github.io/2017/02/22/git使用笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yufeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="御风的博客，keep going！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/22/git使用笔记/" itemprop="url">git使用笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-22T22:03:23+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>git是一种分布式版本控制工具，可以使用命令行和客户端操作两种方式。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/22/git使用笔记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="yufeng" />
          <p class="site-author-name" itemprop="name">yufeng</p>
           
              <p class="site-description motion-element" itemprop="description">大前端、算法方向</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhoufusong" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/users/24f0e7bdca4b/timeline" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yufeng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  








  






  





  

  

  

  

  

  

</body>
</html>
